# springCoreBasic
스프링 핵심원리 기본편 정리



OCP, DIP 객체지향 설계원칙 준수하여 설계 및 개발



## 의존관계 분석

1. 추상(인터페이스) 뿐만 아니라 구현 클래스 까지 확인 → 클래스가 아닌 "인터페이스"를 의존하도록 변경필요

- 인터페이스만 의존하도록 변경하려면 별도로 인터페이스 구현 객체를 대신 생성 및 주입해줘야 함.
  → 애플리케이션의 전체 동작방식을 구성하기 위해 구현객체를 "생성"하고 "연결"하는 책임을 가지는 별도 클래스를 설정


- SRP(단일책임원칙)		> Appconfig를 통해 구현객체를 생성하고 연결
- DIP(읜존관계역전원칙)	> 추상화 인터페이스에만 의존하도록 변경 및 Appconfig를 통해 의존관계를 주입
- OCP(객체지향)		> 다형성을 사용하고 DIP를 지킴





## IoC

프레임워크가 대신 코드를 호출해주는 역활을 하는 것



## IoC 컨테이너, DI 컨테이너

- AppConfig처럼 객체를 생성하고 관리하면서 의존관계를 연결해주는 역활
- 의존관계 주입에 초첨을 맞추어 DI 컨테이너라고 부름 (또는 어샘블러 or 오브젝트 팩토리)




## 스프링 컨테이너

- 이전에는 직접 객체를 생성해서 DI를 했지만, 스프링 컨테이너를 통해서 사용
- @Configuration이 붙은 설정정보를 사용해서 @Bean 메서드를 모두 호출해서 반환되는 객체를 스프링 컨테이너에 등록 → 이렇게 등록된 객체를 "스프링 빈"이러고 부름
- 스프링 빈은 @Bean이 붙은 "메서드 이름"으로 사용
- 필요한 객체를 스프링 컨테이너에 등록된 스프링 빈을 불러서 사용 → applicationContext.getBean()을 통해서 메서드를 찾아서 사용







## 스프링 컨테이너 생성과정

1) 스프링 컨테이저 생성

- 스프링 컨테이너 생성 시 "스프링 빈 저장소" 생성
- 스프링 컨테이너를 생성할 때는 구성 정보를 지정해줘야 함 (빈 이름/빈 객체)
- 스프링 컨테이너는 파라미터로 넘어온 설정 클래스 정보를 사용해서 스프링 빈을 등록


2) 스프링 빈 의존관계 설정

- 스프링 컨테이너는 설정 정보를 참고해서 의존관계를 주입(DI)



## BeanFactory와 ApplicationContext

1) BranFactory
- 스프링 컨테이너의 최상위 인터페이스
- 스프링 빈을 관리하고 조회하는 역활 (getBean 제공)

2) ApplicationContext
- BeanFactory 기능을 모두 상속받아서 제공



## 스프링 컨테이너 설정방법

1) 자바코드 (어노테이션 사용하는 방법)

2) XML (레거시 프로젝트에서 사용했던 방법)

3) Groovy




## 싱글톤 패턴의 문제점 > 유연성이 떨어짐

1) 구현하는 코드 자체가 많이 들어간다.
2) 의존관계상 클라이언트가 구현 클래스에 의존한다, (DIP 위반)
3) 클라이언트가 구현 클래스에 의존해서 OCP원칙을 위반할 가능성이 높다.
4) 테스트 하기가 어렵다.
5) 내부 속성을 변경하거나 초기화 하기가 어렵다.
6) private 생성자로 자식 클래스를 만들기 어렵다.



# 스프링 컨테이너

- 싱글톤 패턴을 적용하지 않아도 객체 인스턴스를 싱글톤(1개만 생성)으로 관리 > 싱글톤 컨테이너 역활
- 싱글톤 패턴 단점을 보안



# ★★싱글톤 방식의 주의점

- 여러 클라이언트가 같은 객체를 공유하기 때문에 상태를 유지하게 설계하면 안된다!


>1) 특정 클라이언트에 의존적인 필드가 있으면 안된다.
>2) ☆특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다
>3) 가급적 읽기만 가능해야 한다 
>4) 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다 
> * ★스프링 빈의 필드에 공유 값을 설정하면 큰 장애가 발생할 수 있다★
